diff -ur CM12.1_laganxx/bootable/recovery/uncrypt/uncrypt.c CM12.1_laganxx_patched/bootable/recovery/uncrypt/uncrypt.c
--- CM12.1_laganxx/bootable/recovery/uncrypt/uncrypt.c	2016-02-23 18:37:53.000000000 +0000
+++ CM12.1_laganxx_patched/bootable/recovery/uncrypt/uncrypt.c	2016-02-23 18:58:07.000000000 +0000
@@ -423,7 +423,10 @@
     // On /data we want to convert the file to a block map so that we
     // can read the package without mounting the partition.  On /cache
     // and /sdcard we leave the file alone.
-    if (strncmp(path, "/data/", 6) != 0) {
+    //
+    // HACK: ignore above: block map is only used with encryption device
+    // for compatibility with older recoveries
+    if (!encrypted || strncmp(path, "/data/", 6) != 0) {
         // path does not start with "/data/"; leave it alone.
         unlink(RECOVERY_COMMAND_FILE_TMP);
     } else {
diff -ur CM12.1_laganxx/build/core/tasks/kernel.mk CM12.1_laganxx_patched/build/core/tasks/kernel.mk
--- CM12.1_laganxx/build/core/tasks/kernel.mk	2016-02-23 18:37:53.000000000 +0000
+++ CM12.1_laganxx_patched/build/core/tasks/kernel.mk	2016-02-23 19:00:48.000000000 +0000
@@ -202,7 +202,11 @@
     ccache := $(strip $(wildcard $(ccache)))
 endif
 
-KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+ifneq ($(TARGET_KERNEL_CUSTOM_TOOLCHAIN),)     
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/linux-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"      
+else
+	KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+endif
 ccache =
 
 define mv-modules
diff -ur CM12.1_laganxx/external/icu/icu4c/source/common/ucnv.c CM12.1_laganxx_patched/external/icu/icu4c/source/common/ucnv.c
--- CM12.1_laganxx/external/icu/icu4c/source/common/ucnv.c	2016-02-23 18:39:27.000000000 +0000
+++ CM12.1_laganxx_patched/external/icu/icu4c/source/common/ucnv.c	2016-02-01 03:51:42.000000000 +0000
@@ -2914,6 +2914,76 @@
             return FALSE;
     }
 }
+
+U_CAPI void    U_EXPORT2 ucnv_setToUCallBack_48 (UConverter * converter,
+                            UConverterToUCallback newAction,
+                            const void* newContext,
+                            UConverterToUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+  ucnv_setToUCallBack(converter, newAction, newContext,
+        oldAction, oldContext, err);
+}
+
+U_CAPI void  U_EXPORT2 ucnv_close_48 (UConverter * converter) {
+  ucnv_close (converter);
+}
+
+U_CAPI void  U_EXPORT2
+ucnv_setFromUCallBack_48 (UConverter * converter,
+                            UConverterFromUCallback newAction,
+                            const void* newContext,
+                            UConverterFromUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+
+  ucnv_setFromUCallBack(converter, newAction, newContext, oldAction,
+        oldContext, err);
+}
+
+U_CAPI void U_EXPORT2
+ucnv_convertEx_48 (UConverter *targetCnv, UConverter *sourceCnv,
+               char **target, const char *targetLimit,
+               const char **source, const char *sourceLimit,
+               UChar *pivotStart, UChar **pivotSource,
+               UChar **pivotTarget, const UChar *pivotLimit,
+               UBool reset, UBool flush,
+               UErrorCode *pErrorCode) {
+  ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source,
+        sourceLimit, pivotStart, pivotSource,
+        pivotTarget, pivotLimit, reset, flush,
+        pErrorCode);
+}
+
+U_CAPI UConverter* U_EXPORT2
+ucnv_open_48 (const char *name,
+                       UErrorCode * err) {
+  return ucnv_open(name, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_FROM_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterFromUnicodeArgs *fromUArgs,
+                  const UChar* codeUnits,
+                  int32_t length,
+                  UChar32 codePoint,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits,
+      length, codePoint, reason, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_TO_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterToUnicodeArgs *toUArgs,
+                  const char* codeUnits,
+                  int32_t length,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length,
+      reason, err);
+}
+
 #endif
 
 /*
diff -ur CM12.1_laganxx/external/sepolicy/domain.te CM12.1_laganxx_patched/external/sepolicy/domain.te
--- CM12.1_laganxx/external/sepolicy/domain.te	2016-02-23 18:40:02.000000000 +0000
+++ CM12.1_laganxx_patched/external/sepolicy/domain.te	2016-02-23 19:07:47.000000000 +0000
@@ -220,11 +220,11 @@
 # init starts in kernel domain and switches to init domain via setcon in
 # the init.rc, so the setenforce occurs while still in kernel. After
 # switching domains, there is never any need to setenforce again by init.
-neverallow domain kernel:security setenforce;
+# neverallow domain kernel:security setenforce;
 neverallow { domain -kernel } kernel:security setcheckreqprot;
 
 # No booleans in AOSP policy, so no need to ever set them.
-neverallow domain kernel:security setbool;
+# neverallow domain kernel:security setbool;
 
 # Adjusting the AVC cache threshold.
 # Not presently allowed to anything in policy, but possibly something
diff -ur CM12.1_laganxx/frameworks/av/media/libstagefright/MPEG4Writer.cpp CM12.1_laganxx_patched/frameworks/av/media/libstagefright/MPEG4Writer.cpp
--- CM12.1_laganxx/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-23 18:40:16.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-23 19:11:17.000000000 +0000
@@ -2298,8 +2298,8 @@
 
         timestampUs -= previousPausedDurationUs;
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         if (!mIsAudio) {
@@ -2314,8 +2314,8 @@
             cttsOffsetTimeUs =
                     timestampUs - decodingTimeUs;
             if (WARN_UNLESS(kMaxCttsOffsetTimeUs >= decodingTimeUs - timestampUs, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                //copy->release();
+                //return ERROR_MALFORMED;
             }
 
             timestampUs = decodingTimeUs;
@@ -2326,8 +2326,8 @@
             currCttsOffsetTimeTicks =
                     (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL;
             if (WARN_UNLESS(currCttsOffsetTimeTicks <= 0x0FFFFFFFFLL, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                //copy->release();
+                //return ERROR_MALFORMED;
             }
 
             if (mStszTableEntries->count() == 0) {
@@ -2368,8 +2368,8 @@
         }
 
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         ALOGV("%s media time stamp: %" PRId64 " and previous paused duration %" PRId64,
@@ -2389,12 +2389,12 @@
         if (currDurationTicks < 0ll) {
             ALOGE("timestampUs %" PRId64 " < lastTimestampUs %" PRId64 " for %s track",
                 timestampUs, lastTimestampUs, trackName);
-            copy->release();
-            err = UNKNOWN_ERROR;
-            mSource->notifyError(err);
-            copy->release();
-            copy = NULL;
-            return err;
+            //copy->release();
+			//err = UNKNOWN_ERROR;
+			//mSource->notifyError(err);
+            //copy->release();
+            //copy = NULL;
+            //return err;
         }
 
         // if the duration is different for this sample, see if it is close enough to the previous
@@ -2492,7 +2492,7 @@
     }
 
     if (isTrackMalFormed()) {
-        err = ERROR_MALFORMED;
+        //err = ERROR_MALFORMED;
     }
 
     mOwner->trackProgressStatus(mTrackId, -1, err);
diff -ur CM12.1_laganxx/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java CM12.1_laganxx_patched/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java
--- CM12.1_laganxx/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java	2016-02-23 18:40:29.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java	2016-02-23 19:13:47.000000000 +0000
@@ -237,6 +237,7 @@
     // Timestamp of the last call to user activity.
     private long mLastUserActivityTime;
     private long mLastUserActivityTimeNoChangeLights;
+	private long mLastButtonActivityTime;
 
     // Timestamp of last interactive power hint.
     private long mLastInteractivePowerHintTime;
@@ -1155,6 +1156,10 @@
                     return true;
                 }
             } else {
+				if (eventTime > mLastButtonActivityTime && (event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
+                    mLastButtonActivityTime = eventTime;
+                    mDirty |= DIRTY_USER_ACTIVITY;
+                }
                 if (eventTime > mLastUserActivityTime) {
                     mLastUserActivityTime = eventTime;
                     mDirty |= DIRTY_USER_ACTIVITY;
@@ -1667,7 +1672,7 @@
                             mKeyboardLight.setBrightness(mKeyboardVisible ?
                                     keyboardBrightness : 0);
                             if (mButtonTimeout != 0
-                                    && now > mLastUserActivityTime + mButtonTimeout) {
+                                    && now > mLastButtonActivityTime + mButtonTimeout) {
                                 mButtonsLight.setBrightness(0);
                             } else {
                                 if (!mProximityPositive) {
diff -ur CM12.1_laganxx/frameworks/base/telephony/java/android/telephony/TelephonyManager.java CM12.1_laganxx_patched/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
--- CM12.1_laganxx/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-23 18:40:29.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-23 19:17:09.000000000 +0000
@@ -3017,49 +3017,22 @@
      * @hide
      */
     public static void setTelephonyProperty(int phoneId, String property, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
+        
 
         if (!SubscriptionManager.isValidPhoneId(phoneId)) {
             Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " prop=" + prop);
+                    " property=" + property + " value: " + value);
             return;
         }
 
-        for (int i = 0; i < phoneId; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
-        }
-
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = phoneId + 1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-
-        if (property.length() > SystemProperties.PROP_NAME_MAX
-                || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
-            Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " propVal=" + propVal);
-            return;
+       
+        if (phoneId > 0) {
+            property += "_" + phoneId;
         }
 
         Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId +
-                " property=" + property + " value: " + value + " propVal=" + propVal);
-        SystemProperties.set(property, propVal);
+                " property=" + property + " value: " + value);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -3156,17 +3129,22 @@
      * @hide
      */
     public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
-                propVal = values[phoneId];
-            }
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            Rlog.d(TAG, "getTelephonyProperty: invalid phoneId=" + phoneId +
+                    " property=" + property);
+            return defaultVal;
+        }
+
+        if (phoneId > 0) {
+            property += "_" + phoneId;
         }
+		
+		String propVal = SystemProperties.get(property);
+		
         Rlog.d(TAG, "getTelephonyProperty: return propVal='" + propVal + "' phoneId=" + phoneId
-                + " property='" + property + "' defaultVal='" + defaultVal + "' prop=" + prop);
-        return propVal == null ? defaultVal : propVal;
+                + " property='" + property + "' defaultVal='" + defaultVal);
+
+        return propVal.isEmpty() ? defaultVal : propVal;
     }
 
     /**
diff -ur CM12.1_laganxx/frameworks/native/libs/gui/BufferQueueProducer.cpp CM12.1_laganxx_patched/frameworks/native/libs/gui/BufferQueueProducer.cpp
--- CM12.1_laganxx/frameworks/native/libs/gui/BufferQueueProducer.cpp	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/native/libs/gui/BufferQueueProducer.cpp	2016-02-01 03:51:42.000000000 +0000
@@ -204,7 +204,12 @@
             const int newUndequeuedCount =
                 maxBufferCount - (dequeuedCount + 1);
             const int minUndequeuedCount =
+#ifdef HAWAII_HWC
+                // HACK: for some reason, we need to reduce min undequeue for screen recording
+                mCore->getMinUndequeuedBufferCountLocked(false);
+#else			
                 mCore->getMinUndequeuedBufferCountLocked(async);
+#endif			
             if (newUndequeuedCount < minUndequeuedCount) {
                 BQ_LOGE("%s: min undequeued buffer count (%d) exceeded "
                         "(dequeued=%d undequeued=%d)",
@@ -1032,4 +1037,4 @@
     disconnect(api);
 }
 
-} // namespace android
+} // namespace android
\ No newline at end of file
diff -ur CM12.1_laganxx/frameworks/native/libs/gui/SensorEventQueue.cpp CM12.1_laganxx_patched/frameworks/native/libs/gui/SensorEventQueue.cpp
--- CM12.1_laganxx/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-23 19:18:33.000000000 +0000
@@ -130,8 +130,12 @@
 
 status_t SensorEventQueue::enableSensor(int32_t handle, int32_t samplingPeriodUs,
                                         int maxBatchReportLatencyUs, int reservedFlags) const {
-    return mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
-                                                 us2ns(maxBatchReportLatencyUs), reservedFlags);
+    status_t err = mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
+                                                 us2ns(maxBatchReportLatencyUs), reservedFlags);											 
+	if (err == NO_ERROR) {
+        mSensorEventConnection->setEventRate(handle, us2ns(samplingPeriodUs));
+    }
+    return err;											 
 }
 
 status_t SensorEventQueue::flush() const {
diff -ur CM12.1_laganxx/frameworks/native/libs/gui/SurfaceComposerClient.cpp CM12.1_laganxx_patched/frameworks/native/libs/gui/SurfaceComposerClient.cpp
--- CM12.1_laganxx/frameworks/native/libs/gui/SurfaceComposerClient.cpp	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/native/libs/gui/SurfaceComposerClient.cpp	2016-02-23 19:18:51.000000000 +0000
@@ -838,7 +838,7 @@
         uint32_t minLayerZ, uint32_t maxLayerZ, bool useIdentityTransform) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
-#ifdef USE_MHEAP_SCREENSHOT
+#if defined(USE_MHEAP_SCREENSHOT) && !defined(HAWAII_HWC)
     int format = 0;
     producer->query(NATIVE_WINDOW_FORMAT,&format);
     if (format == PIXEL_FORMAT_RGBA_8888) {
diff -ur CM12.1_laganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp CM12.1_laganxx_patched/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- CM12.1_laganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-23 19:22:10.000000000 +0000
@@ -1052,13 +1052,18 @@
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+// HAWAII_HWC does not respect planeAlpha despite being v1.2
+	#ifndef HAWAII_HWC		
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+	#endif		
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+	#ifndef HAWAII_HWC		
         }
+	#endif	
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff -ur CM12.1_laganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java CM12.1_laganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- CM12.1_laganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-23 19:24:04.000000000 +0000
@@ -226,6 +226,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+	boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -447,6 +448,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+        // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+		
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -1913,6 +1919,18 @@
     public void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+
+        // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+		
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -2345,6 +2363,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur CM12.1_laganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java CM12.1_laganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
--- CM12.1_laganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-23 18:40:32.000000000 +0000
+++ CM12.1_laganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-23 19:24:21.000000000 +0000
@@ -301,7 +301,7 @@
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
-    static final String[] SOCKET_NAME_RIL = {"rild", "rild2", "rild3"};
+    static final String[] SOCKET_NAME_RIL = {"rild", "rild1", "rild2"};
 
     static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
 
diff -ur CM12.1_laganxx/packages/apps/Dialer/src/com/android/dialer/DialtactsActivity.java CM12.1_laganxx_patched/packages/apps/Dialer/src/com/android/dialer/DialtactsActivity.java
--- CM12.1_laganxx/packages/apps/Dialer/src/com/android/dialer/DialtactsActivity.java	2016-02-23 18:40:47.000000000 +0000
+++ CM12.1_laganxx_patched/packages/apps/Dialer/src/com/android/dialer/DialtactsActivity.java	2016-02-23 19:44:44.000000000 +0000
@@ -174,6 +174,13 @@
      * Animation that slides out.
      */
     private Animation mSlideOut;
+	
+	AnimationListenerAdapter mSlideInListener = new AnimationListenerAdapter() {
+        @Override
+        public void onAnimationEnd(Animation animation) {
+            maybeEnterSearchUi();
+        }
+    };
 
     /**
      * Listener for after slide out animation completes on dialer fragment.
@@ -308,7 +315,7 @@
                 final boolean sameSearchMode = (mIsDialpadShown && mInDialpadSearch) ||
                         (!mIsDialpadShown && mInRegularSearch);
                 if (!sameSearchMode) {
-                    enterSearchUi(mIsDialpadShown, mSearchQuery);
+                    enterSearchUi(mIsDialpadShown, mSearchQuery, true /* animate */);
                 }
             }
 
@@ -333,7 +340,8 @@
         public void onClick(View v) {
             if (!isInSearchUi()) {
                 mActionBarController.onSearchBoxTapped();
-                enterSearchUi(false /* smartDialSearch */, mSearchView.getText().toString());
+                enterSearchUi(false /* smartDialSearch */, mSearchView.getText().toString(),
+                        true /* animate */);
             }
         }
     };
@@ -443,6 +451,8 @@
 
         mSlideIn.setInterpolator(AnimUtils.EASE_IN);
         mSlideOut.setInterpolator(AnimUtils.EASE_OUT);
+		
+		mSlideIn.setAnimationListener(mSlideInListener);
 
         mSlideOut.setAnimationListener(mSlideOutListener);
 
@@ -751,12 +761,11 @@
         } else {
             mFloatingActionButtonController.setVisible(false);
             onFloatingActionButtonHidden();
+			 maybeEnterSearchUi();
         }
         mActionBarController.onDialpadUp();
 
-        if (!isInSearchUi()) {
-            enterSearchUi(true /* isSmartDial */, mSearchQuery);
-        }
+        mListsFragment.getView().animate().alpha(0).withLayer();
 
         mDialpadFragment.enableSmartCall(true);
     }
@@ -983,7 +992,7 @@
     /**
      * Shows the search fragment
      */
-    private void enterSearchUi(boolean smartDialSearch, String query) {
+    private void enterSearchUi(boolean smartDialSearch, String query, boolean animate) {
         if (mStateSaved || getFragmentManager().isDestroyed()) {
             // Weird race condition where fragment is doing work after the activity is destroyed
             // due to talkback being on (b/10209937). Just return since we can't do any
@@ -1012,7 +1021,11 @@
         mInRegularSearch = !smartDialSearch;
 
         SearchFragment fragment = (SearchFragment) getFragmentManager().findFragmentByTag(tag);
-        transaction.setCustomAnimations(android.R.animator.fade_in, 0);
+        if (animate) {
+            transaction.setCustomAnimations(android.R.animator.fade_in, 0);
+        } else {
+            transaction.setTransition(FragmentTransaction.TRANSIT_NONE);
+        }
         if (fragment == null) {
             if (smartDialSearch) {
                 fragment = new SmartDialSearchFragment();
@@ -1026,10 +1039,14 @@
         // DialtactsActivity will provide the options menu
         fragment.setHasOptionsMenu(false);
         fragment.setShowEmptyListForNullQuery(true);
-        fragment.setQueryString(query, false /* delaySelection */);
+        if (!smartDialSearch) {
+            fragment.setQueryString(query, false /* delaySelection */);
+        }
         transaction.commit();
 
-        mListsFragment.getView().animate().alpha(0).withLayer();
+        if (animate) {
+            mListsFragment.getView().animate().alpha(0).withLayer();
+        }
         mListsFragment.setUserVisibleHint(false);
     }
 
@@ -1086,6 +1103,12 @@
             super.onBackPressed();
         }
     }
+	
+	private void maybeEnterSearchUi() {
+        if (!isInSearchUi()) {
+            enterSearchUi(true /* isSmartDial */, mSearchQuery, false);
+        }
+    }
 
     /**
      * @return True if the search UI was exited, false otherwise
diff -ur CM12.1_laganxx/packages/apps/Settings/src/com/android/settings/sim/MultiSimEnablerPreference.java CM12.1_laganxx_patched/packages/apps/Settings/src/com/android/settings/sim/MultiSimEnablerPreference.java
--- CM12.1_laganxx/packages/apps/Settings/src/com/android/settings/sim/MultiSimEnablerPreference.java	2016-02-23 18:40:52.000000000 +0000
+++ CM12.1_laganxx_patched/packages/apps/Settings/src/com/android/settings/sim/MultiSimEnablerPreference.java	2016-02-23 19:28:11.000000000 +0000
@@ -229,7 +229,9 @@
         super.onBindView(view);
 
         mSwitch = (Switch) view.findViewById(com.android.internal.R.id.switchWidget);
-        mSwitch.setClickable(true);
+         // Disable manual provisioning
+        mSwitch.setClickable(false);
+        mSwitch.setVisibility(View.INVISIBLE);
 
         update();
     }
diff -ur CM12.1_laganxx/packages/services/Telephony/res/values/strings.xml CM12.1_laganxx_patched/packages/services/Telephony/res/values/strings.xml
--- CM12.1_laganxx/packages/services/Telephony/res/values/strings.xml	2016-02-23 18:40:56.000000000 +0000
+++ CM12.1_laganxx_patched/packages/services/Telephony/res/values/strings.xml	2016-02-23 19:29:02.000000000 +0000
@@ -609,12 +609,14 @@
     </string-array>
 
     <string-array name="enabled_networks_except_lte_choices" translatable="false">
-        <item>@string/network_3G</item>
-        <item>@string/network_2G</item>
+        <item>@string/preferred_network_mode_wcdma_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_wcdma_preferred_choice</item>
     </string-array>
     <string-array name="enabled_networks_except_lte_values" translatable="false">
-        <item>"0"</item>
+        <item>"2"</item>
         <item>"1"</item>
+        <item>"0"</item>
     </string-array>
 
     <string-array name="enabled_networks_except_gsm_lte_choices" translatable="false">
diff -ur CM12.1_laganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java CM12.1_laganxx_patched/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
--- CM12.1_laganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-23 18:40:56.000000000 +0000
+++ CM12.1_laganxx_patched/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-23 19:30:43.000000000 +0000
@@ -2351,10 +2351,13 @@
      * This is useful for implementing "HomeAsUp" capability for second-level Settings.
      */
     public static void goUpToTopLevelSetting(Activity activity) {
-        Intent intent = new Intent(activity, CallFeaturesSetting.class);
-        intent.setAction(Intent.ACTION_MAIN);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        activity.startActivity(intent);
+        // HACK: See MSimMobileNetworkSubSettings#onOptionsItemSelected
+        if (!PhoneUtils.isMultiSimEnabled()) {
+            Intent intent = new Intent(activity, CallFeaturesSetting.class);
+            intent.setAction(Intent.ACTION_MAIN);
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            activity.startActivity(intent);
+        }
         activity.finish();
     }
 }
diff -ur CM12.1_laganxx/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java CM12.1_laganxx_patched/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java
--- CM12.1_laganxx/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-23 18:40:56.000000000 +0000
+++ CM12.1_laganxx_patched/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-23 19:30:58.000000000 +0000
@@ -523,11 +523,11 @@
 
         mEnabledNetworksSummaries = new SparseIntArray();
         mEnabledNetworksSummaries.append(Phone.NT_MODE_WCDMA_PREF,
-                R.string.network_wcdma_pref);
+               R.string.preferred_network_mode_gsm_wcdma_preferred_choice);
         mEnabledNetworksSummaries.append(Phone.NT_MODE_GSM_ONLY,
-                R.string.network_gsm_only);
+               R.string.preferred_network_mode_gsm_only_choice);
         mEnabledNetworksSummaries.append(Phone.NT_MODE_WCDMA_ONLY,
-                R.string.network_wcdma_only);
+               R.string.preferred_network_mode_wcdma_only_choice);
         mEnabledNetworksSummaries.append(Phone.NT_MODE_GSM_UMTS,
                R.string.network_gsm_umts);
         mEnabledNetworksSummaries.append(Phone.NT_MODE_CDMA,
diff -ur CM12.1_laganxx/system/core/libnetutils/ifc_utils.c CM12.1_laganxx_patched/system/core/libnetutils/ifc_utils.c
--- CM12.1_laganxx/system/core/libnetutils/ifc_utils.c	2016-02-23 18:43:23.000000000 +0000
+++ CM12.1_laganxx_patched/system/core/libnetutils/ifc_utils.c	2016-02-01 03:51:42.000000000 +0000
@@ -711,3 +711,19 @@
 
     return 0;
 }
+
+// Required for Broadcom RILD
+int ifc_set_mtu(const char *name, int mtuSz)
+{
+    struct ifreq ifr;
+    int ret;
+    ifc_init_ifr(name, &ifr);
+    ifr.ifr_mtu = mtuSz;
+
+    ret = ioctl(ifc_ctl_sock, SIOCSIFMTU, &ifr);
+    if (ret < 0) {
+        printerr("ifc_set_mtu: SIOCSIFMTU failed: %d\n", ret);
+    }
+
+    return ret;
+}
\ No newline at end of file
